<?php
/*
#doc-start
h1.  render_ajax.php - AJAX dispatcher

Created by  on 2010-03-11.
 
bq. Copyright Mike Howard and Clove Technologies, Inc, 2008-2010.
All Rights Reserved.

h1. Ajax API Design

The API and functionality are encapsulated in the class *AjaxRequest*.

For any request, one and only one AjaxRequest instance will exist and
will be available globally in Globals::$web_service.

The actualization of the AJAX request is executed by the *render_ajax.php*
script - which:

* defines and instantiates the AjaxRequest class and object, assigning the
object to the variable Globals::$web_service
* locates and executes the requested ajax request script
* implements, executes, and responds to the AJAX request script API
* produces all output which is sent to the client

This API only accepts data passed to the AJAX request via the POST HTTP
method. All passed data can be accessed through the RequestCleaner variable:
Globals::$rc. See "RequestCleaner":/doc.d/system-includes/request_cleaner.html

Here are the relevant parts of this document.

* "render_ajax.php - top level AJAX processer":#render_ajax
* "HTTP Response Codes":#http_codes
* "AjaxRequest Class":#ajax_request
* "ajax request script API":#script_api

h2(#render_ajax). render_ajax.php

*render_ajax.php* expects two parameters provided by a POST request:

* data_format - which specifies the format the request data will be returned
in. This will be one of _json, jsonp, xml, script, html,_ or _text_.
* ajax_request - which MUST be the name of an includeable file in
_private_data_root / ajax_scripts_

If either parameter is missing, the script immediately responds with
a *400* HTTP error - Bad Request and supplies an explanatory message.

If the required script is not in the _ajax_scripts_ directory, then
it responds with a *404* - Not Found - error, again with an explanatory
message.

Then it declares and instantiates an "AjaxRequest":#ajax_request object
and executes the ajax_request script by reading the script into a string
and then using the PHP language construct _eval(). The script is not
evalauted using _include_ or _require_ in order to enforce the script location
requirements [this is a feature].

The _ajax_request_ will define two functions as described "below":#script_api.

If the _ajax_request_ fails to define the required functions, then *render_ajax.php*
returns *500* Internal Server Error with explanatory note. It also emails
the site technical content as given in Globals::$webmaster.

It then proceeds to check for required authority and execute _ajax_request_,
returning HTTP result codes as given in the "HTTP Return Codes table":#http_codes

h2(#http_codes). HTTP Return Codes

|Code|HTTP Meaning|AJAX request success/failure|Content|Generated By|Notes|
|200|OK|success|content returned|ajax_request script|
|400|Bad Request|failure|failure content|render_ajax.php / ajax_request script|
|401|Unauthorized|-|-|render_ajax.php|required_authorization not met|
|403|Forbidden|-|-|render_ajax.php / ajax_request script|required_authorization == FORBIDDEN|
|404|Not Found|-|-|render_ajax.php|unable to load ajax request script|
|412|Precondition Failed|failure|-|typically cookies missing or is robot or something
|500|Internal Server Error|-|format mismatch|render_ajax.php|request returned inappropriately formatted data|
|503|Service Unavailable|-|-|render_ajax.php|database is not online|

h2(#ajax_request). AjaxRequest Class

h3. Instantiation

<pre>
$foo = AjaxRequest::get_instance(data_format, ajax_request_script)
</pre>

Where:

* data_format is one of the legal data formats defined below
* ajax_request_script is a script in _private_data_root_ / 'ajax_scripts_

h3. Attributes

* ajax_request - read only - name of ajax script - expected to be in _private_data_root / ajax_scripts_
* callback - read only - only used for JSONP data format - name of callback function
* content - read/write - data which will be returned to the AJAX requestor. It is
initialized to empty, according to data_format. Returned data, if any, maybe added
by the _ajax_request_ script using the _add_content()_ method.
The argument of _add_content()_ must be an associative array for _json_, _xml_, and
_jsonp_ data format; must be a string for _html_, _script_, and _text_.
See the _data_format_ section below.
* data_format - read only - allowed values with required _ajax_request_ content
and returned data are defined "here":#data_format
* error_message - read only - error messages accumulated during the request
* eval_result - boolean - TRUE if _ajax_request_ was found and included
* required_authority - read/write - Account authority required for request. Legal
values are comma separated list of authorities, 'ANY', and 'FORBIDDEN'.
Defaults to 'FORBIDDEN'.

h4(#data_format). Data Format

|Data Format^1^|ajax_request content^2^|returned MIME-type^3^|
|json|associative array|application/json|
|jsonp|associateve array|application/javascript|
|xml|associative array|application/xml|
|html|html text|text/html|
|script|javascript as text||
|text|UTF-8 text|text/plain|

# Data Format - ascii string defining the data format to be returned by this
AJAX request
# _ajax_request_ content - the data type which the _ajax_request_ must assign
to the _content_ attribute of the AjaxRequest object
# returned MIME-type - the value of the Content-Type header which is returned
to the client when the AJAX request finishes successfully


h3. Class Methods

None

h3. Instance Methods

Instance methods all return TRUE upon successful completion and FALSE upon
failure.

* add_content($content) - called by ajax_request to append content to
the AjaxRequest object.
* add_error($error_message) - appends _$error_message_ to the _error_message_
attribute. Does not indicate success or failure.
* set_http_status_line($status_code, $reason_phrase) - sets the HTTP status
line as specified. _ajax_request_ scripts call this method to indicate errors.
The default values are: '200' and 'OK'.
* render() - renders and returns the result of the AJAX call.

h3. Returned Data

Returned data is formatted according to one of the six allowable data formats above.

The response will always contain:

* result - either 'success' or 'failure'
* explanation - which may be empty

If the request was successful, then it may also contain other key/value pairs - as supplied
by the _ajax_request_.

The format will of these returned key/value pairs depends on the data format requested.

* json, jsonp - JSON key/value pairs in object form
* xml - XML elements with key in the element tag and value in the content of the lement
* html, text - formatted human readable
* script - this is the exception: if the _ajax_request_ returns a string, then that string
is returned; if it returns anything else, then an array consisting of all keys/value pairs
is returned as text. [This is open to revision]


h2(#script_api). _ajax_request_ Script Requirements

Each _ajax_request_ script must define two functions.

Scripts are not expected to produce output. All output from
scripts is collected and discarded.

IMPORTANT: because the script is executed using the _eval()_ language construct, it must
consist ONLY of PHP code and comments. PHP escapes back and forth to HTML are not allowed.
In fact, any occurance of &lt;?php or ?&gt; are deleted prior to passing the script
to _eval()_, so if you have them in the script, the script will fail.

It is recommended that the ajax_request script begin with the &lt;?php escape sequence
because this allows us to easily create a compacted version of the script using
command line PHP processor with the -w option. See the Makefile to see how it is
done in creating the distribution tar files.

h4. ajax_set_required_authority() 

*ajax_set_required_authority()* is responsible for setting
Globals::$web_service->required_authority to enforce security for this AJAX request.

To do so, it may examine the state of the session, relationship between objects and the
currently active Account (if one is active). It does not need to consider the 'logged_in'
status of the active Account, as that is handled by this module.

It may set the value of Globals::$web_service->required_authority to a value OR leave it
in its default state: FORBIDDEN. Legal values may be the distinguished tokens 'ANY' and 
'FORBIDDEN' and any legal authority as defined in "Account.php":/doc.d/system-objects/Account.html.

h5. Returns

Return code will be one of the following three character ascii strings:

|Return Code|HTTP Meaning|Condition|
|200|OK|if _required_authority_ is set to any non-FORBIDDEN value|
|400|Bad Request|if the requested data format is not supported|
|403|FORBIDDEN|if _required_authority_ is set to 'FORBIDDEN'|

h4. ajax_content()

*ajax_content()* performs whatever is required for the specific request. It retrieves
posted data by using Globals::$rc - the global "RequestCleaner":/doc.d/system-includes/request_cleaner.html
object.

Content is queued for return to the calling client by using the _add_content()_
method of Globals::$web_service. Error messages are queued by calling the
_add_error()_ message with a string describing the type of error encountered.

Content is genrerally an associative array for data types _json_, _jsonp_, and
_xml_ data formats; it is string data for _html_ and _text_ formats.

*ajax_content()* returns TRUE if successful and FALSE if it fails.

The AJAX request handler manages the actual transmission to the calling client.

h4. Returns

Either the PHP values of TRUE or FALSE.
#end-doc
*/

// function definitions

function fail($status_code, $reason_phrase, $content_type = "text/plain", $content = '')
{
  $reason_phrase = preg_replace('/\s+/', ' ', $reason_phrase);
  header("HTTP/1.1 $status_code $reason_phrase");
  header("Content-Type: $content_type");
  header("Content-Length: " . strlen($content));
  echo $content;
  exit(1);
} // end of fail()

// end function definitions

// setup code
// return Service Unavailable if the database is not on-line
if (Globals::$dbaccess->on_line != 'T') {
  fail('503', "Site Offline");
}
//validate data format
switch (Globals::$rc->safe_get_data_format) {
  case 'xml':
  case 'html':
  case 'script':
  case 'json':
  case 'text':
  case 'jsonp':
    break;
  default:
    fail('400', "Bad Request - Illegal data_format: '" . Globals::$rc->safe_get_data_format . "'");
    return;
}
if (!Globals::$rc->safe_get_ajax_request) {
  fail('400', "Bad Request - Missing ajax_request script");
  return;
}
$ajax_request_path = Globals::$private_data_root . DIRECTORY_SEPARATOR . 'ajax_scripts'
  . DIRECTORY_SEPARATOR . Globals::$rc->safe_get_ajax_request;
if (!is_file($ajax_request_path)) {
  $ajax_request_path = Globals::$private_data_root . DIRECTORY_SEPARATOR . 'system'
    . DIRECTORY_SEPARATOR . 'ajax_scripts'
    . DIRECTORY_SEPARATOR . Globals::$rc->safe_get_ajax_request;
  if (!is_file($ajax_request_path)) {
    fail('404', "Not Found - ajax_request script '" . Globals::$rc->safe_get_ajax_request . "' not found");
    return;
  }
}
if (!is_readable($ajax_request_path)) {
  fail('404', "Bad Request - ajax_request script '" . Globals::$rc->safe_get_ajax_request . "' not readable");
  return;
}

// read the script and strip out an PHP escapes. We will eval() it AFTER we've defined
//  and instantiated the AjaxRequest object.
// $ajax_request_str contains the content of the request. It will be parsed using 'eval()'
//  when the AjaxRequest object is instantiated.
// NOTE: the backslashes keep the PHP escape sequences from escaping to and from PHP in this
//  next line of code, but they work in the regx because \f === f for any non-special escape
//  character 'f'.
$ajax_request_str = preg_replace(array('/<\?php/', '/\?\>/'), array('', ''), file_get_contents($ajax_request_path));

// end setup code 

// class definitions

class AjaxRequest {
  private static $instance = NULL; // this is a singleton object just as a precaution against stupidity.
  private $ajax_request;
  private $callback;
  private $content;
  private $explanation;
  private $data_format;
  private $error_message = '';
  private $eval_result;
  private $required_authority = 'FORBIDDEN';
  private $rendered = FALSE;
  private $status_code = '200';
  private $reason_phrase = 'OK';
  
  private function __construct($data_format, $ajax_request)
  {
    $this->ajax_request = $ajax_request;
    switch (($this->data_format = $data_format)) {
      case 'xml':
      case 'json':
        $this->content = array();
        break;
      case 'text':
      case 'html':
      case 'script':
        $this->content = '';
        break;
      case 'jsonp':
        $this->callback = Globals::$rc->safe_post_callback;
        $this->content = array();
        break;
    }
    
    // if ($this->eval_result === FALSE) {
    //   fail('400', "Bad Request - Parse Error in $ajax_request");
    // }
  }
  
  public static function get_instance($data_format, $ajax_request)
  {
    if (!AjaxRequest::$instance) {
      AjaxRequest::$instance = new AjaxRequest($data_format, $ajax_request);
    }
    return AjaxRequest::$instance;
  } // end of get_instance()

  public function __toString()
  {
    return "AjaxRequest($this->data_format, $this->ajax_request)";
  } // end of __toString()

  public function __get($name)
  {
    switch ($name) {
      case 'ajax_request':
      case 'callback':
      case 'content':
      case 'explanation':
      case 'data_format':
      case 'error_message':
      case 'eval_result':
      case 'required_authority':
      case 'rendered':
      case 'status_code':
      case 'reason_phrase':
        return $this->$name;
      default:
        $this->add_error("AjaxRequest::__get($name): illegal attribute '$name'");
        break;
    }
  } // end of __get()
  
  public function __set($name, $value)
  {
    switch ($name) {
      case 'ajax_request':
      case 'callback':
      case 'data_format':
      case 'error_message':
      case 'eval_result':
      case 'rendered':
      case 'content':
      case 'explanation':
      case 'status_code':
      case 'reason_phrase':
        $this->add_error( "AjaxRequest::__set($name, ...): attempt to set read-only attribute '$name'");
        break;
      case 'required_authority':
        $this->$name = $value;
        break;
      default:
        $this->add_error( "AjaxRequest::__get($name): illegal attribute '$name'");
        break;
    }
  } // end of __set()
  
  public function __isset($name)
  {
    return isset($this->name);
  } // end of __isset()
  
  public function __unset($name)
  {
    $this->add_error("AjaxRequest::__unset($name): attempt to unset '$name'");
  } // end of unset()
  
  public function add_error($error_message)
  {
    if ($this->error_message)
      $this->error_message .= "\n$error_message";
    else
      $this->error_message = $error_message;
    return TRUE;
  } // end of add_error()
  
  public function add_content($content)
  {
    ob_start();
    echo "Adding content to AjaxRequest\n";
    var_dump($content);
    file_put_contents('/tmp/bar', ob_get_clean());
    
    if ($this->rendered === FALSE) {
      switch ($this->data_format) {
        case 'json':
        case 'jsonp':
        case 'xml':
          if (!is_array($content)) {
            $this->add_error("add_content(arg): arg is not array - array required for $this->data_format");
            fail('500', "Internal Server Error - script $this->ajax_request returned incorrect data format for $this->data_format");
            return FALSE;
          } else {
            $this->content = array_merge($this->content, $content);
          }
          break;
        case 'html':
        case 'script':
        case 'text':
          if (!is_string($content)) {
            $this->add_error("add_content(arg): arg is not string - array required for $this->data_format");
            fail('500', "Internal Server Error - script $this->ajax_request returned incorrect data format for $this->data_format");
            return FALSE;
          } else {
            $this->content .= $content;
          }
          break;
      }
      return TRUE;
    } else {
      return FALSE;
    }
  } // end of success()
  
  private function set_http_status_line($staus_code, $reason_phrase)
  {
    switch ($status_code) {
      case '200':
      case '400':
      case '401':
      case '401':
      case '404':
      case '500':
        $this->status_code = $status_code;
        $this->reason_phrase = $reason_phrase;
        return TRUE;
      default:
        $this->status_code = '500';
        $this->reason_phrase = "Attempt to set status code to illegal value: $status_code / $reason_phrase";
        return FALSE;
    }
  } // end of set_http_status_line()
  
  
  public function render()
  {
    if ($this->rendered !== FALSE) {
      return FALSE;
    }
    $this->rendered = TRUE;

    // spit out common headers
    header("HTTP/1.1 {$this->status_code} {$this->reason_phrase}");
    header("Cache-Control: no-cache, must-revalidate"); // HTTP/1.1
    header("Expires: Sat, 26 Jul 1997 05:00:00 GMT"); // Date in the past

    switch ($this->data_format) {
      case 'json':
        header("Content-Type: application/json");
        $payload = json_encode($this->content);
        break;
      case 'jsonp':
        header("Content-Type: text/javascript");
        if (!$this->callback)
          $this->callback = 'alert';
        $payload =  $this->callback . '(' . json_encode($this->content) . ');';
        break;
      case 'xml':
        header("Content-Type: application/xml");
        $payload = "<?xml version=\"1.0\"?>\n" . $this->xml_encode_helper(0, array('content' => $this->content));
        break;
      case 'html':
        header("Content-Type: text/html");
        $payload = $this->content;
        break;
      case 'script':
        header("Content-Type: text/javascript");
        $payload = $this->content;
        break;
      case 'text':
        header("Content-Type: text/plain");
        $payload = $this->content;
        break;
    }
    
    ob_start();
    echo $this->dump();
    var_dump($payload);
    debug_print_backtrace();
    file_put_contents('/tmp/render_ajax.out', ob_get_clean());
    header("Content-Length: " . strlen($payload));
    echo $payload;
  } // end of emit_data()
  
  private function xml_encode_helper($level, $data)
  {
    $str = '';
    $indent = str_repeat(' ', $level);
    foreach ($data as $key => $val) {
      if (is_string($val)) {
        $str .= $val ? "{$indent}<{$key}>$val</$key>\n" : "{$indent}<$key />\n";
      } elseif (is_array($val)) {
        $str .= "{$indent}<{$key}>\n" . $this->xml_encode_helper($level + 1, $val) . "{$indent}</$key>\n";
      } else {
        $str .= "{$indent}<{$key} />\n";
      }
    }
    return $str;
  } // end of xml_encode_helper()
  
  public function dump($msg = '')
  {
    $str = "AjaxRequest dump\n$msg\n";
    foreach (get_object_vars($this) as $attr => $value) {
      $str .= " Attr: $attr: $value\n";
    }
    return $str;
  } // end of dump()
}

// end class definitions

// function definitions


// end function definitions

// preliminary screening
if (Globals::$flag_is_robot) {
  fail('412', 'Client is Robot');
}
if (!Globals::$flag_cookies_ok) {
  fail('412', 'Cookies Required');
}

Globals::$web_service = AjaxRequest::get_instance(Globals::$rc->safe_get_data_format,
    Globals::$rc->safe_get_ajax_request);

// at this point we are ready to run the script - which we do inside output buffering
//  so we can discard any output and keep it from mucking up the return.
// we also do this here so that the script has access to the AjaxRequest object.
ob_start();
eval($ajax_request_str);
ob_clean();

if (!function_exists('ajax_set_required_authority')) {
  file_put_contents('/tmp/foo', "required function not defined\n");
  fail('400', "Bad Request - $this->ajax_request did not define ajax_set_required_authority()");
}

if (!function_exists('ajax_content')) {
  file_put_contents('/tmp/foo', "required function not defined\n");
  fail('400', "Bad Request - $this->ajax_request did not define ajax_content()");
}

$set_required_authority_result = ajax_set_required_authority();

switch ($set_required_authority_result) {
  case '200':
    break;
  case '400':
    fail($set_required_authority_result, "Data format not supported");
    return;
  case '403':
    fail($set_required_authority_result, "ajax request is forbidden");
    return;
  default:
    $reason_phrase =  Globals::$web_service->error_message ? Globals::$web_service->error_message
      : "Internal Error - " . Globals::$web_service->ajax_request . ":ajax_set_required_authority() returned illegal value";
    fail($set_required_authority_result ? $set_required_authority_result : '500',
        preg_replace('/\s+/', ' ', $reason_phrase));
    return;
}

if (Globals::$web_service->required_authority == 'ANY') {
  switch (ajax_content()) {
    case TRUE: Globals::$web_service->render(); return;
    case FALSE: fail('400', "Bad Request - " . Globals::$web_service->error_message); return;
    default: fail('500', "Internal Server Error - ajax_content() did not return TRUE or FALSE" . Globals::$web_service->error_message); return;
  }
} elseif (!(Globals::$account_obj instanceof Account)) {
  fail('401', "Unauthorized - You Must be a Registered User - please log in");
  return;
} elseif (!Globals::$account_obj->logged_in()) {
  fail('401', 'Unauthorized - Your Session is not Active - Please Login In');
  return;
} elseif (Globals::$account_obj->has_authority(Globals::$web_service->required_authority)) {
  switch (ajax_content()) {
    case TRUE: Globals::$web_service->render(); return;
    case FALSE: fail('400', "Bad Request - " . Globals::$web_service->error_message); return;
    default: fail('500', "Internal Server Error - ajax_content() did not return TRUE or FALSE" . Globals::$web_service->error_message); return;
  }
} else {
  fail('403', 'Forbidden - You Don\'t have Sufficient Authority to Do This');
  return;
}
fail('500', "Internal Server Error - line: " . __LINE__);
?>
